using System;
using System.Runtime.CompilerServices;
using Unravel.Core;

/// <summary>
/// Weapon that automatically targets and shoots at enemies within range.
/// Handles automatic firing, enemy detection, and projectile spawning.
/// </summary>
[ScriptSourceFile]
public class Weapon : ScriptComponent
{
    //[Header("Weapon Settings")]
    [Tooltip("Rate of fire in shots per second")]
    public float fireRate = 2.0f;
    [Tooltip("Maximum shooting range (also used for enemy detection)")]
    public float range = 15.0f;
    [Tooltip("Damage dealt by projectiles")]
    public float damage = 25.0f;
    
    //[Header("Projectile Settings")]
    [Tooltip("Projectile prefab to instantiate when shooting")]
    public Prefab projectile;
    [Tooltip("Container entity for organizing projectiles in hierarchy")]
    public Entity projectileContainer;
    [Tooltip("Force applied to projectiles when fired")]
    public float projectileForce = 25.0f;
    [Tooltip("Projectile lifetime in seconds before auto-destruction")]
    public float projectileLifetime = 5.0f;
    [Tooltip("Spread angle in degrees for projectile accuracy (0 = perfect accuracy)")]
    public float spread = 5.0f;
    [Tooltip("Number of projectiles to fire per shot")]
    public int projectileCount = 1;
    
    [Tooltip("Require line of sight to target (raycast check)")]
    public bool requireLineOfSight = false;
    
    //[Header("Weapon Effects")]
    [Tooltip("Effects that this weapon can apply to targets")]
    public WeaponEffectData[] weaponEffects = new WeaponEffectData[0];
    
    //[Header("Debug Settings")]
    [Tooltip("Enable debug logging for weapon operations")]
    public bool debugWeapon = false;
    [Tooltip("Draw debug spheres for weapon range")]
    public bool debugDrawRanges = false;
    
    // Component references
    private TransformComponent transformComponent;
    
    // Weapon state
    private float timeSinceLastShot = 0.0f;
    private Entity currentTarget;
    
    /// <summary>
    /// Called when the script is created. Initialize component references.
    /// </summary>
    public override void OnCreate()
    {
        // Get required components
        transformComponent = owner.GetComponent<TransformComponent>();
        
        if (transformComponent == null)
        {
            Log.Error($"Weapon on {owner.name}: TransformComponent not found!");
        }
        
        // Validate projectile
        if (projectile == null)
        {
            Log.Warning($"Weapon on {owner.name}: No projectile prefab assigned!");
        }
    }

    /// <summary>
    /// Called when the script starts execution.
    /// </summary>
    public override void OnStart()
    {
        // Validate components
        if (transformComponent == null)
        {
            Log.Error($"Weapon on {owner.name}: Missing required components. Disabling script.");
            return;
        }

        // Auto-find projectile container if not assigned
        if (!projectileContainer)
        {
            // Try to find or create a projectile container
            var containerEntity = Scene.FindEntityByName("ProjectileContainer");
            if (containerEntity)
            {
                projectileContainer = containerEntity;
                if (debugWeapon)
                {
                    Log.Info($"Weapon: Found existing ProjectileContainer");
                }
            }
            else
            {
                if (debugWeapon)
                {
                    Log.Info($"Weapon: No ProjectileContainer found, projectiles will spawn without parent");
                }
            }
        }
        
        
        // ExampleWeaponConfigs.ConfigureWeapon(this, "poisondart");

    }
    
    /// <summary>
    /// Called every frame to update weapon logic.
    /// </summary>
    public override void OnUpdate()
    {
        if (transformComponent == null || projectile == null)
            return;
            
        // Update firing timer
        timeSinceLastShot += Time.deltaTime;
        
        // Check if we can fire
        if (CanFire())
        {
            // Find target
            Entity target = FindClosestEnemy();
            
            if (target)
            {
                currentTarget = target;
                
                // Calculate shooting direction
                Vector3 shootDirection = CalculateShootDirection(target);
                
                // Fire weapon
                FireWeapon(shootDirection);
                
                // Reset fire timer
                timeSinceLastShot = 0.0f;
                
                if (debugWeapon)
                {
                    Log.Info($"Weapon: Fired at {target.name} at distance {Vector3.Distance(transformComponent.position, target.transform.position):F2}");
                }
            }
        }
        
        // Debug drawing
        if (debugDrawRanges)
        {
            DrawDebugRanges();
        }
    }
    
    /// <summary>
    /// Check if the weapon can fire based on fire rate.
    /// </summary>
    /// <returns>True if weapon can fire.</returns>
    private bool CanFire()
    {
        float fireInterval = 1.0f / fireRate;
        return timeSinceLastShot >= fireInterval;
    }
    
    /// <summary>
    /// Find the closest enemy within range using SphereOverlap.
    /// </summary>
    /// <returns>The closest enemy entity, or Entity.Invalid if none found.</returns>
    private Entity FindClosestEnemy()
    {
        Vector3 weaponPosition = transformComponent.position;
        
        // Perform sphere overlap to find potential targets
        var overlaps = Physics.SphereOverlap(weaponPosition, range, LayerMask.GetMask("Enemy"));
        
        if (overlaps == null || overlaps.Length == 0)
        {
            return Entity.Invalid;
        }
        
        Entity closestEnemy = Entity.Invalid;
        float closestDistance = float.MaxValue;
        
        // Find the closest valid enemy
        foreach (var entity in overlaps)
        {            
            if (!entity) continue;
            
            // Skip self
            if (entity == owner) continue;
            
            // Calculate distance
            float distance = Vector3.Distance(weaponPosition, entity.transform.position);
            
            // Check if within range
            if (distance > range) continue;
            
            // Check line of sight if required
            if (requireLineOfSight && !HasLineOfSight(entity)) continue;
            
            // Check if this is the closest so far
            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestEnemy = entity;
            }
        }
        
        return closestEnemy;
    }
    
    
    /// <summary>
    /// Check if there's a clear line of sight to the target.
    /// </summary>
    /// <param name="target">The target entity.</param>
    /// <returns>True if line of sight is clear.</returns>
    private bool HasLineOfSight(Entity target)
    {
        Vector3 weaponPosition = transformComponent.position;
        Vector3 targetPosition = target.transform.position;
        Vector3 direction = (targetPosition - weaponPosition).normalized;
        float distance = Vector3.Distance(weaponPosition, targetPosition);
        
        // Raycast to check for obstacles
        var hit = Physics.Raycast(weaponPosition, direction, distance, -1, false);
        
        // If we hit something, check if it's the target
        if (hit.HasValue)
        {
            return hit.Value.entity == target;
        }
        
        // No obstacles found
        return true;
    }
    
    /// <summary>
    /// Calculate the shooting direction towards the target.
    /// </summary>
    /// <param name="target">The target entity.</param>
    /// <returns>The normalized shooting direction.</returns>
    private Vector3 CalculateShootDirection(Entity target)
    {
        Vector3 weaponPosition = transformComponent.position;
        Vector3 targetPosition = target.transform.position;
        
        // Calculate direction to target
        Vector3 direction = (targetPosition - weaponPosition).normalized;
        
        return direction;
    }
    
    /// <summary>
    /// Fire the weapon in the specified direction.
    /// </summary>
    /// <param name="shootDirection">The direction to shoot.</param>
    private void FireWeapon(Vector3 shootDirection)
    {
        Vector3 weaponPosition = transformComponent.position + Vector3.up * 2.0f;
        Shoot(weaponPosition, shootDirection, spread, projectileCount);
    }
    
    /// <summary>
    /// Shoot projectiles with proper angular spread from the source position.
    /// </summary>
    /// <param name="source">The source position for projectiles.</param>
    /// <param name="shootDir">The base shooting direction.</param>
    /// <param name="spread">The spread angle in degrees (cone angle).</param>
    /// <param name="count">The number of projectiles to spawn.</param>
    private void Shoot(Vector3 source, Vector3 shootDir, float spread, int count)
    {
        for (int i = 0; i < count; ++i)
        {
            var instance = Scene.Instantiate(projectile);
            
            // Set parent if container exists
            if (projectileContainer)
            {
                instance.transform.parent = projectileContainer;
            }
            
            // Calculate spread direction using angular deviation
            Vector3 spreadDirection = CalculateSpreadDirection(shootDir, spread);
            
            // Set projectile position at source (no position spread, only angular)
            instance.transform.position = source;
            
            // Set projectile orientation to face the spread direction
            instance.transform.forward = spreadDirection;

            // Apply physics force in the spread direction
            var iphysics = instance.GetComponent<PhysicsComponent>();
            if (iphysics != null)
            {
                iphysics.ApplyForce(spreadDirection * projectileForce, ForceMode.Impulse);
            }
            
            // Configure projectile component if it exists
            var projectileComp = instance.AddComponent<Projectile>();
            if (projectileComp != null)
            {
                projectileComp.SetSourceEntity(owner);
                
                // Pass weapon effects to projectile
                projectileComp.SetWeaponEffects(weaponEffects);
                projectileComp.SetWeaponDamage(damage);
 
                if (debugWeapon)
                {
                    Log.Info($"Weapon: Configured projectile {instance.name} with source {owner.name}, damage {damage}, and {weaponEffects.Length} effects");
                }
            }
            else
            {
                // Fallback: Auto-destroy after lifetime if no Projectile
                Scene.DestroyEntity(instance, projectileLifetime);
            }
        }
    }
    
    /// <summary>
    /// Calculate a spread direction by applying random angular deviation on the horizontal plane (X,Z only).
    /// </summary>
    /// <param name="baseDirection">The base shooting direction.</param>
    /// <param name="spreadAngle">The maximum spread angle in degrees.</param>
    /// <returns>A direction vector with applied horizontal spread.</returns>
    private Vector3 CalculateSpreadDirection(Vector3 baseDirection, float spreadAngle)
    {
        if (spreadAngle <= 0)
            return baseDirection;
            
        // Convert spread angle from degrees to radians
        float spreadRadians = spreadAngle * Mathf.Deg2Rad;
        
        // Generate random deviation angle within the spread range
        float randomDeviation = Random.Range(-spreadRadians, spreadRadians);
        
        // Project base direction onto XZ plane (remove Y component)
        Vector3 horizontalDirection = new Vector3(baseDirection.x, 0, baseDirection.z).normalized;
        
        // If the base direction is purely vertical, use forward as default
        if (horizontalDirection.sqrMagnitude < 0.01f)
        {
            horizontalDirection = Vector3.forward;
        }
        
        // Calculate the spread direction by rotating around the Y axis
        float currentAngle = Mathf.Atan2(horizontalDirection.z, horizontalDirection.x);
        float newAngle = currentAngle + randomDeviation;
        
        // Create the new horizontal direction
        Vector3 spreadDirection = new Vector3(
            Mathf.Cos(newAngle),
            baseDirection.y, // Preserve original Y component
            Mathf.Sin(newAngle)
        );
        
        return spreadDirection.normalized;
    }
    
    /// <summary>
    /// Draw debug visualization for weapon ranges.
    /// </summary>
    private void DrawDebugRanges()
    {
        Vector3 weaponPosition = transformComponent.position;
        
        // This would typically use a debug drawing system
        // For now, we'll just log the ranges periodically
        if (Time.time % 2.0f < Time.deltaTime) // Every 2 seconds
        {
            if (debugWeapon)
            {
                Log.Info($"Weapon Debug - Range: {range}, Position: {weaponPosition}");
            }
        }
    }
    
    /// <summary>
    /// Get the current target entity.
    /// </summary>
    /// <returns>The current target entity.</returns>
    public Entity GetCurrentTarget()
    {
        return currentTarget;
    }
    
    /// <summary>
    /// Get the time until the next shot can be fired.
    /// </summary>
    /// <returns>Time in seconds until next shot.</returns>
    public float GetTimeUntilNextShot()
    {
        float fireInterval = 1.0f / fireRate;
        return Mathf.Max(0.0f, fireInterval - timeSinceLastShot);
    }
    
    /// <summary>
    /// Check if the weapon is ready to fire.
    /// </summary>
    /// <returns>True if ready to fire.</returns>
    public bool IsReadyToFire()
    {
        return CanFire();
    }
    
    /// <summary>
    /// Set the fire rate of the weapon.
    /// </summary>
    /// <param name="newFireRate">New fire rate in shots per second.</param>
    public void SetFireRate(float newFireRate)
    {
        fireRate = Mathf.Max(0.1f, newFireRate);
    }
    
    /// <summary>
    /// Set the weapon range.
    /// </summary>
    /// <param name="newRange">New weapon range.</param>
    public void SetRange(float newRange)
    {
        range = Mathf.Max(0.1f, newRange);
    }
    
    /// <summary>
    /// Set the weapon damage.
    /// </summary>
    /// <param name="newDamage">New damage value.</param>
    public void SetDamage(float newDamage)
    {
        damage = Mathf.Max(0.0f, newDamage);
    }
}
